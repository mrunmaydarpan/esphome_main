uart:
  baud_rate: 9600
  rx_pin: $srx_pin
  tx_pin: $stx_pin
  id: uart_id
  debug:
    direction: RX
    dummy_receiver: True  # Receive bytes without a UARTDevice component [web:40][web:46]
    after:
      timeout: 100ms      # Collect bursts before invoking sequence [web:42]
    sequence:
      - lambda: |-
          // bytes: std::vector<uint8_t>; parse 0xFF H L SUM frames [web:50]
          static std::vector<uint8_t> buf;
          buf.insert(buf.end(), bytes.begin(), bytes.end()); // Append new bytes

          while (buf.size() >= 4) {                          // Try to extract full 4-byte frames
            auto it = std::find(buf.begin(), buf.end(), 0xFF);    // Seek header 0xFF
            if (it == buf.end()) { buf.clear(); break; }
            buf.erase(buf.begin(), it);                           // Remove leading noise
            if (buf.size() < 4) break;
            uint8_t h = buf[0];
            uint8_t dH = buf[1];
            uint8_t dL = buf[2];
            uint8_t sum = buf[3];
            uint8_t calc = (uint8_t)(h + dH + dL);                // Validate header and checksum: (0xFF + dH + dL) & 0xFF == sum [web:50]
            
            if (h == 0xFF && calc == sum) 
            {
              uint16_t mm = ((uint16_t)dH << 8) | dL;
              int cm = mm / 10; // Datasheet: distance in mm [web:50]
              id(sensor_id).publish_state(cm);  // Publish distance [web:41]
            }
            
            // Consume this frame
            buf.erase(buf.begin(), buf.begin() + 4);
          }
          // UARTDebug::log_string(direction, bytes);

sensor:
  - platform: template
    id: sensor_id
    name: "Distance_UART"
    unit_of_measurement: "cm"
    device_class: distance
    accuracy_decimals: 0
    entity_category: "diagnostic"
    # update_interval: 1s
    filters:
      - throttle: 2s
      # - timeout: 5s
